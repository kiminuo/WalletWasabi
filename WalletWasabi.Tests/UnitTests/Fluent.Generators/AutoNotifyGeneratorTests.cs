using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WalletWasabi.Fluent.Generators;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System.Diagnostics;
using System.Reflection;
using Xunit;

namespace WalletWasabi.Tests.UnitTests.Fluent.Generators
{
	/// <summary>
	/// Tests for <see cref="AutoNotifyGenerator"/>.
	/// </summary>
	/// <seealso href="https://github.com/dotnet/roslyn/blob/master/docs/features/source-generators.cookbook.md#unit-testing-of-generators"/>
	public class AutoNotifyGeneratorTests
	{
		[Fact]
		public void SimpleGeneratorTest()
		{
			// Create the 'input' compilation that the generator will act on
			Compilation inputCompilation = CreateCompilation(@"
namespace WalletWasabi.Fluent.ViewModels
{
	public class TestViewModel2
	{
		[AutoNotify(PropertyName = ""TestName"")] private bool _prop1;
		[AutoNotify(SetterModifier = AccessModifier.None)] private bool _prop2 = false;
		[AutoNotify(SetterModifier = AccessModifier.Public)] private bool _prop3;
		[AutoNotify(SetterModifier = AccessModifier.Protected)] private bool _prop4;
		[AutoNotify(SetterModifier = AccessModifier.Private)] private bool _prop5;
		[AutoNotify(SetterModifier = AccessModifier.Internal)] private bool _prop6;
	}
}
");

			AutoNotifyGenerator generator = new AutoNotifyGenerator();

			// Create the driver that will control the generation, passing in our generator
			GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);

			// Run the generation pass
			// (Note: the generator driver itself is immutable, and all calls return an updated version of the driver that you should use for subsequent calls)
			driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation, out var diagnostics);

			// We can now assert things about the resulting compilation:
			Assert.True(diagnostics.IsEmpty); // there were no diagnostics created by the generators

			// We have 4 syntax trees, the original provided by user, and remaining ones generated by the generator.
			Assert.Equal(4, outputCompilation.SyntaxTrees.Count());
			// Assert.True(outputCompilation.GetDiagnostics().IsEmpty); // verify the compilation with the added source has no diagnostics

			// Or we can look at the results directly:
			GeneratorDriverRunResult runResult = driver.GetRunResult();

			// The runResult contains the combined results of all generators passed to the driver
			Assert.Equal(3, runResult.GeneratedTrees.Length);
			Assert.True(runResult.Diagnostics.IsEmpty);

			// Or you can access the individual results on a by-generator basis
			GeneratorRunResult generatorResult = runResult.Results[0];
			Assert.Equal(generatorResult.Generator, generator);
			Assert.True(generatorResult.Diagnostics.IsEmpty);
			Assert.Equal(3, generatorResult.GeneratedSources.Length);

			string expectedGeneratedSourceCode = @"
// <auto-generated />
#nullable enable
using ReactiveUI;

namespace WalletWasabi.Fluent.ViewModels
{
    public partial class TestViewModel2 : ReactiveUI.ReactiveObject
    {
        public bool TestName
        {
            get => _prop1;
            set => this.RaiseAndSetIfChanged(ref _prop1, value);
        }
        public bool Prop2
        {
            get => _prop2;
        }
        public bool Prop3
        {
            get => _prop3;
            set => this.RaiseAndSetIfChanged(ref _prop3, value);
        }
        public bool Prop4
        {
            get => _prop4;
            protected set => this.RaiseAndSetIfChanged(ref _prop4, value);
        }
        public bool Prop5
        {
            get => _prop5;
            private set => this.RaiseAndSetIfChanged(ref _prop5, value);
        }
        public bool Prop6
        {
            get => _prop6;
            internal set => this.RaiseAndSetIfChanged(ref _prop6, value);
        }
    }
}".Trim();


			Assert.Equal(expectedGeneratedSourceCode, generatorResult.GeneratedSources[2].SourceText.ToString());

			Assert.True(generatorResult.Exception is null);
		}

		private static Compilation CreateCompilation(string source)
			=> CSharpCompilation.Create("compilation",
				syntaxTrees: new[] { CSharpSyntaxTree.ParseText(source) },
				references: new[] {
					MetadataReference.CreateFromFile(typeof(Binder).GetTypeInfo().Assembly.Location),
					MetadataReference.CreateFromFile(typeof(ReactiveUI.ReactiveObject).GetTypeInfo().Assembly.Location),
				},
				new CSharpCompilationOptions(OutputKind.ConsoleApplication));
	}
}